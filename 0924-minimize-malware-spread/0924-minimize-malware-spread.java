class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        /*
            Algorithms & DS: #BFS
            Time: O(n^2), Extra Space: O(n)

        */
        int n = graph.length;
        boolean[] network = new boolean[n];
        int minimizeInitial = Integer.MAX_VALUE, minimize = Integer.MAX_VALUE;

        for(int infectedNode : initial){
            network[infectedNode] = true;
        }

        for(int curedNode : initial){
            boolean[] infectedNetwork = network.clone();
            Queue<Integer> q = new LinkedList<>();

            infectedNetwork[curedNode] = false;

            for(int infectedNode = 0; infectedNode < infectedNetwork.length; infectedNode++){
                if(infectedNetwork[infectedNode]){
                    q.offer(infectedNode);
                }
            }

            while (!q.isEmpty()){
                int i = q.poll();

                for(int j = 0; j < n; j++){
                    if(graph[i][j] == 1 && !infectedNetwork[j]){
                        infectedNetwork[j] = true;
                        q.offer(j);
                    }
                }
            }

            int infectedNodeCount = 0;
            for(boolean isInfected : infectedNetwork){
                if(isInfected){
                    infectedNodeCount++;
                }
            }

            if(infectedNodeCount < minimize) {
                minimize = infectedNodeCount;
                minimizeInitial = curedNode;
            }
            else if(infectedNodeCount == minimize && curedNode < minimizeInitial){
                minimizeInitial = curedNode;
            }
        }
        
        return minimizeInitial;
    }
}